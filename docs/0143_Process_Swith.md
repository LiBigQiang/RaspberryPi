# Process Swith

如果每个进程地址空间都是4G，MMU做虚拟地址映射，每次进程切换都要切换映射表？

## 参考文档


* [内核页表和进程页表](https://blog.csdn.net/andylauren/article/details/70305863)
* [0074_Core_Files.md](0074_Core_Files.md)

## 简要说明

* 内核页表：在内核中其实就是一段内存，存放在主内核页全局目录init_mm.pgd(swapper_pg_dir)中，硬件并不直接使用；
* 进程页表：每个进程自己的页表，放在进程自身的页目录task_struct.pgd中；
* 在保护模式下，从硬件角度看，其运行的基本对象为"进程"(或线程)，而寻址则依赖于"进程页表"，在进程调度而进行上下文切换时，会进行页表的切换：即将新进程的pgd(页目录)加载到CR3寄存器中。从这个角度看，其实是完全没有用到"内核页表"的，那么"内核页表"有什么用呢？跟"进程页表"有什么关系呢？
  * 内核页表中的内容为所有进程共享，每个进程都有自己的"进程页表"，"进程页表"中映射的线性地址包括两部分：
    * 用户态
    * 内核态
      * 内核态地址对应的相关页表项，对于所有进程来说都是相同的(因为内核空间对所有进程来说都是共享的)，而这部分页表内容其实就来源于"内核页表"，即每个进程的"进程页表"中内核态地址相关的页表项都是"内核页表"的一个拷贝。
* "内核页表"由内核自己维护并更新，

## Coredump

* 查阅文档(man 7 signal)，SIGSEGV 默认handler的动作是打印"段错误"的出错信息，并产生Core文件；
* 进程收到SIGSEGV信号产生Core文件；
* 注意g++ 编译的时候，需要使用参数-g，否则GDB 无法找到symbol 信息，从而无法定位问题；
* 进入调试模式后执行bt 以显示程序的调用栈信息；
* [0074_Core_Files.md](0074_Core_Files.md)

## signal的含义

* SIGABRT：调用abort函数时产生此信号。进程异常终止。
* SIGBUS：指示一个实现定义的硬件故障。
* SIGEMT：指示一个实现定义的硬件故障。EMT这一名字来自PDP-11的emulator trap 指令。
* SIGFPE：此信号表示一个算术运算异常，例如除以0，浮点溢出等。
* SIGILL：此信号指示进程已执行一条非法硬件指令。4.3BSD由abort函数产生此信号。SIGABRT现在被用于此。
* SIGIOT：这指示一个实现定义的硬件故障。IOT这个名字来自于PDP-11对于输入/输出TRAP(input/outputTRAP)指令的缩写。系统V的早期版本，由abort函数产生此信号。SIGABRT现在被用于此。
* SIGQUIT：当用户在终端上按退出键（一般采用Ctrl-/）时，产生此信号，并送至前台进程组中的所有进程。此信号不仅终止前台进程组（如SIGINT所做的那样），同时产生一个core文件。
* SIGSEGV：指示进程进行了一次无效的存储访问。名字SEGV表示"段违例（segmentationviolation）"。
* SIGSYS：指示一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，但其指示系统调用类型的参数却是无效的。
* SIGTRAP：指示一个实现定义的硬件故障。此信号名来自于PDP-11的TRAP指令。SIGXCPUSVR4和4.3+BSD支持资源限制的概念。如果进程超过了其软CPU时间限制，则产生此信号。
* SIGXFSZ：如果进程超过了其软文件长度限制，则SVR4和4.3+BSD产生此信号。
